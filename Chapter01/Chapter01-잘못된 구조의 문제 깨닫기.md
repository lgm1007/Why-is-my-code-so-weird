# Chapter01. 잘못된 구조의 문제 깨닫기
## 요약 정리
* 의미를 알 수 없는, 읽고 이해하는 데 오랜 시간이 걸리는 이름 사용을 지양한다.
  * 의도와 목적을 드러내는 이름을 사용하기만 해도 구조가 간단하고 명확해진다.
* 조건 분기의 중첩은 복잡해질 수록 이해하기 어렵고, 이해하지 못한 채로 기능을 변경하면 버그가 발생할 수 있다.
* 데이터밖에 가지고 있지 않은 클래스인 데이터 클래스 사용을 지양하자.
  * 코드 중복, 수정 누락, 가독성 저하, 초기화되지 않은 상태(쓰레기 객체), 잘못된 값 할당과 같은 문제가 발생한다.
* 일단 나쁜 구조의 폐해를 인지한다.
* 객체 지향 설계가 곧 악마를 퇴치하는 무기이다.

## 의미를 알 수 없는 이름
* 좋지 않은 이름이 불러오는 악영향
  * 자료형 이름, 메모리 제어 등 프로그래밍이나 컴퓨터 용어를 기반으로 이름을 붙이는 것을 기술 중심 명명이라고 함
    * `int intValue01`
    * `updateStateFlag()`
    * `MemoryStateManager`
  * 클래스와 메서드에 번호를 붙여서 이름 짓는 것을 일련번호 명명이라고 함
    * `method001()`
    * `Class001`
  * 위와 같은 이름들은 코드에서 **어떠한 의도**도 알 수 없다.
  * 읽고 이해하는 데 오랜 시간이 걸린다.
* **의도와 목적을 드러내는 이름**을 사용하는 것이 좋다.
  * 이렇게만 해도 **구조가 간단하고 명확**해짐


## 이해하기 어렵게 만드는 조건 분기 중첩
* 거대한 if 중첩
```java
if (조건) {
  //
  // 수십~수백 줄의 코드
  //
  if (조건) {
    //
    // 수십~수백 줄의 코드
    //
    if (조건) {
      //
      // 수십~수백 줄의 코드
      //
      if (조건) {
        //
        // 수십~수백 줄의 코드
        //
      }
      // 
      // 수십~수백 줄의 코드
      // 
    }
    //
    // 수십~수백 줄의 코드
    //
  }
  //
  // 수십~수백 줄의 코드
  //
}
```
* 이런 중첩은 조건이 복잡해질 수록 코드를 읽고 이해하기 힘듬
  * 이해가 힘들면 디버깅과 기능 변경에 더 오랜 시간을 들여야 함
  * 로직을 정확히 이해하지 못하고 기능을 변경하면 버그가 발생할 가능성이 생김

## 수많은 악마를 만들어내는 데이터 클래스
* 예시) 데이터밖에 없는 클래스
```java
// 상품
public class Product {
    public int price;
    public String name;
}
```

* 이처럼 데이터를 갖고 있기만 하는 클래스를 **데이터 클래스**라고 함
* 위 `Product` 클래스에서 금액을 계산하는 로직이 필요하다고 할 때, 이 로직을 데이터 클래스가 아닌 다른 클래스에 구현하게 되는 일이 발생

```java
// 상품 관리 클래스
public class ProductManager {
    public Product product;
    
    // 세율을 적용하여 가격을 계산하는 메서드
    public int calculateProductPrice(BigDecimal salesTaxRate) {
        // 
        // 계산 코드
        // 
    }
}
```

* 이러한 구조가 야기할 수 있는 문제들은 다음과 같다.

### 사양을 변경할 때 드러나는 문제
* 세율과 관련된 사양이 변경되었다고 가정하자
  * 세율과 관련된 로직을 찾아서 변경할 것이다.
  * 하지만, 변경된 세율이 적용되지 않았다는 장애 보고가 올라왔다.
  * 찾아보니 다른 곳에서 세율을 사용하여 계산하는 로직이 있었다.
* 왜 이런 일이 일어날까?
  * 계산 로직을 어느 곳에 만들어두면, 만들어놓은 개발자는 사람들이 모두 그것만 사용하겠지 하고 생각할 수 있다.
  * 하지만 다른 사람들은 필요한 로직이 이미 구현되어 있다는 것을 모르고 따로 구현해버릴 수도 있는 것이다.
* 데이터와 로직 등이 분산되어 있는 것을 **응집도가 낮은 구조**라고 한다.
* 다음은 응집도가 낮은 구조에서 발생할 수 있는 문제들이다.

#### 코드 중복
* 위 상황처럼 관련된 코드가 멀리 떨어져있으면 관련된 것끼리 묶어 파악하기 힘들다.
  * 예시처럼, 이미 구현된 기능을 여러 군데에 구현할 수도 있다.

#### 수정 누락
* 코드 중복이 많으면, 사양이 변경될 때 중복된 코드를 모두 찾아서 수정해야 한다.
  * 이 과정에서 일부 코드를 놓치게 될 수 있다.

#### 가독성 저하
* **가독성**: 코드의 의도나 흐름을 얼마나 빠르고 정확하게 읽고 이해할 수 있는지 나타내는 지표
  * 분산되어 있는 코드는 중복된 코드를 포함해서 관련된 정보를 찾는 것만으로 시간이 오래 걸린다.

### 초기화되지 않은 상태 (쓰레기 객체)
```java
Product product = new Product();
System.out.println(product.name);
```
* 위 코드는 null 이 출력될 것이다.
  * `Product`가 추가로 초기화해야 하는 클래스임을 모르면 버그가 발생하기 쉬운 불완전한 클래스이다.
  * 이처럼 `초기화하지 않으면 쓸모 없는 클래스` 또는 `초기화하지 않은 상태가 발생할 수 있는 클래스`를 안티 패턴 **쓰레기 객체**라고 함

### 잘못된 값 할당
* 값이 잘못 할당되었다는 것은 요구 사항에 맞지 않음을 의미
* 예시)
  * 주문 건수가 음수가 나오는 경우
  * 게임에서 HP 값이 최댓값을 넘는 경우
* 잘못된 값이 넘어가지 않게 데이터 클래스를 사용하는 쪽의 로직에서 유효성을 검사하게 만들 수 있다.
  * 하지만 사용하는 곳마다 검사 로직을 추가해야 하니 코드가 중복될 수 있음
  * 그렇게 되면, 앞서 말한 것처럼 응집도가 낮아 생기는 문제가 똑같이 발생할 수 있음

## 악마 퇴치의 기본
* 일단 **나쁜 구조의 폐해를 인지**하기
  * 나쁜 폐해를 인지하면 어떻게든 대처해야겠다고 생각하게 됨, 이 생각이 **좋은 설계를 위한 첫걸음**
* **클래스를 적절하게 설계**하기
  * 객체 지향 설계가 곧 악마를 퇴치하는 무기
