# Chapter05. 응집도:흩어져 있는 것들
## 요약 정리
* **응집도**는 모듈 내부에 있는 데이터와 로직 사이의 관계가 얼마나 강한지를 나타내는 지표이다.
  * 응집도가 높은 구조는 변경하기 쉬우며, 바람직한 구조이다.
  * 응집도가 낮은 구조는 변경 시 문제가 발생하기 쉽다.
* static 메서드 오용으로 응집도가 낮아지는 경우가 있다.
  * static 메서드는 인스턴스 변수를 사용할 수 없다. 따라서 static 메서드를 사용하는 시점에 이미 데이터와 로직 사이에 괴리가 생긴다.
* static 메서드를 사용하는 이유는 객체 지향 언어를 사용할 때, 절차 지향 언어의 접근 방법을 사용하려 하기 때문이다.
* 응집도의 영향을 받지 않는 경우 static 메서드를 사용하도록 한다.
  * 예) 로그 출력 전용, 포맷 변환 전용 메서드, 팩토리 메서드
* 클래스를 잘 설계해도, **초기화 로직이 분산**되어 응집도가 낮은 구조가 되어 버리는 경우가 있다.
  * private 생성자 + 팩토리 메서드를 사용해 목적에 따라 초기화한다.
  * private 생성자를 사용하면 클래스 내부에서만 인스턴스를 생성할 수 있게 된다.
* 생성 로직이 너무 많아지면 팩토리 클래스를 고려해보자.
* **횡단 관심사**: 다양한 상황에서 넓게 활용되는 기능
  * 횡단 관심사에 해당하는 기능이라면 범용 코드로 만들어도 괜찮다.
* 출력으로 매개변수를 사용하면 응집도가 낮아지고, 가독성도 좋지 않아진다.
* 매개변수가 너무 많아지면 클래스 자료형을 고려하자.
* **묻지 말고, 명령하기** (Tell, Don't Ask)
  * 다른 객체의 내부 상태(변수)를 기반으로 판단하거나 제어하려고 하지 말고, 메서드로 명령해서 객체가 알아서 판단하고 제어하도록 설계하라.
  * 인스턴스 변수를 private로 만들고, 인스터스 변수에 대한 제어는 외부에서 메서드로 명령하는 형태로 만든다.

## static 메서드 오용
* **응집도**는 모듈 내부에 있는 데이터와 로직 사이의 관계가 얼마나 강한지를 나타내는 지표이다.
  * 응집도가 높은 구조는 변경하기 쉬우며, 바람직한 구조이다.
  * 응집도가 낮은 구조는 변경 시 문제가 발생하기 쉽다.
* static 메서드를 사용하는 건 무엇이 문제일까?
* 데이터와 데이터를 조작하는 로직이 다르다는 것이 문제이다. 이는 **응집도가 낮은 구조**

### static 메서드는 인스턴스 변수를 사용할 수 없다.
* static 메서드는 인스턴스 변수를 사용할 수 없다.
* 따라서 static으로 메서드를 만드는 순간 데이터와 데이터를 조작하는 로직 사이에 괴리가 생긴다.

### 인스턴스 메서드인 척하는 메서드 주의하기
* static 키워드가 붙어 있지 않을 뿐, static 메서드와 같은 문제를 갖고 있는 인스턴스 메서드도 존재한다.
* 인스턴스 메서드이지만 인스턴스 변수를 사용하지 않는 메서드를 주의해야 한다.
* 인스턴스 메서드인 척하는 메서드를 찾으려 한다면, 메서드 앞에 static 키워드를 추가해보자. IDE에서 오류가 발생하거나, 컴파일이 안될 것이다.

### static 메서드는 왜 사용하는 것이며, 어떤 경우에 사용해야 할까?
* 객체 지향 언어를 사용할 때, 절차 지향 언어의 접근 방법을 사용하려 하기 때문이다.
  * 절차 지향 언어는 데이터와 로직이 따로 존재하도록 설계한다.
* 로그 출력 전용 메서드, 포맷 변환 전용 메서드, 팩토리 메서드와 같이 응집도 영향을 받지 않는 경우 static 메서드를 사용해도 괜찮다.

## 초기화 로직 분산
* 클래스를 잘 설계해도, 초기화 로직이 분산되어 응집도가 낮은 구조가 되어 버리는 경우가 있다.
* 생성자를 public으로 만들면 의도하지 않은 용도로 사용될 수 있다.
  * 관련된 로직이 분산되기 때문에 유지 보수하기 힘들어질 수 있다.

### private 생성자 + 팩토리 메서드를 사용해 목적에 따라 초기화한다.
* 초기화 연산의 분산을 막으려면 생성자를 private로 두고, 대신 목적에 따라 팩토리 메서드를 만든다.
* 팩토리 메서드는 목적에 따라 만들어 두는 것이 일반적이다.
```java
public static GiftPoint forStandardMemberShip() {
    return new GiftPoint(MEMBERSHIP.STANDARD.value());
}

public static GiftPoint forVipMemberShip() {
    return new GiftPoint(MEMBERSHIP.VIP.value());
}
```

### 생성 로직이 너무 많아지면 팩토리 클래스를 고려해보자
* 상황에 따라 생성 로직이 많아질 수 있다. 그러면 해당 클래스가 무엇을 하는 클래스인지 알기 어렵다.
* 이런 경우 생성 전용 팩토리 클래스를 분리하는 방법을 고려해볼 수 있다.

## 범용 처리 클래스 (Common/Util)
* Common, Util 클래스는 static 메서드와 마찬가지로 응집도가 낮은 구조가 만들어질 수 있다.

### 너무 많은 로직이 한 클래스에 모이는 문제
* Common, Util 이라는 이름 자체가 범용이라는 뜻이기 때문에, 이 이름을 본 사람들은 '범용적으로 사용하고 싶은 로직을 모아 두면 되겠구나.' 하고 생각한다.
* 근본적인 원인은 범용의 의미와 재사용성을 잘못 이해하고 있기 때문이다.
  * 재사용성은 설계의 응집도가 높아지면 저절로 높아진다.
* 꼭 필요한 경우가 아니라면 범용 처리 클래스를 만들지 않는 것이 좋다.

### 횡단 관심사
* 다양한 상황에서 넓게 활용되는 기능을 **횡단 관심사**라고 부른다.
  * 대표적으로 다음과 같은 기능들이 있다.
    * 로그 출력
    * 오류 확인
    * 디버깅
    * 예외 처리
    * 캐시
    * 동기화
    * 분산 처리
* 횡단 관심사에 해당하는 기능이라면 범용 코드로 만들어도 괜찮다.

## 결과를 리턴하는 데 매개변수 사용하지 않기
* 출력으로 사용되는 매개변수를 출력 매개변수라고 부른다.
* 데이터와 로직이 각자 다른 클래스에 있는 것. 따라서 응집도가 낮은 구조가 된다.
* 응집도가 낮은 구조는 중복을 만든다.
* 출력 매개변수는 응집도 문제 외에도 여러 문제를 발생시킨다.
  * 매개변수가 입력인지 출력인지 메서드 내부의 로직을 확인해야 한다.
  * 메서드의 내용을 하나하나 확인하게 만드는 구조는 로직을 읽고 이해하는 데 시간이 오래 걸려, 가독성이 좋지 않다.
* 객체 지향 설계의 기본으로 돌아가, **데이터와 데이터를 조작하는 논리를 같은 클래스에 배치**한다.

## 매개변수가 너무 많은 경우
* 매개변수가 너무 많은 메서드는 응집도가 낮아지기 쉽다.
  * 메서드의 매개변수를 전달한다는 것은 해당 매개변수를 사용해서 어떤 기능을 수행하고 싶다는 의미
  * 매개변수가 많다는 것은 많은 기능을 처리하고 싶다는 의미
  * 처리할 게 많아지면 로직이 복잡해지거나, 중복 코드가 생길 가능성이 높아진다.

### 기본 자료형에 대한 집착
* 매개변수와 리턴값에 모두 자료형만 사용하는 등, 기본 자료형을 남용하는 현상을 **기본 자료형 집착**이라고 한다.
* 기본 자료형으로만 구현하려고 하면, 데이터를 사용한 계산과 제어 로직이 모두 **분산**되어 응집도가 낮은 구조가 된다.

### 의미 있는 단위는 모두 클래스로 만들기
* 매개변수가 너무 많아지는 문제를 피하려면, 개념적으로 **의미 있는 클래스**를 만들어야 한다.
* 매개변수가 많으면 데이터 하나하나를 매개변수로 다루지 말고 그 데이터를 인스턴스 변수로 갖는 클래스를 만들고 활용하는 설계로 변경해보자.

## 묻지 말고 명령하기
* **묻지 말고 명령하기** (Tell, Don't Ask) 라는 격언이 있다.
* 다른 객체의 내부 상태(변수)를 기반으로 판단하거나 제어하려고 하지 말고 메서드로 명령해서 객체가 알아서 판단하고 제어하도록 설계하라는 의미
* 인스턴스 변수에 대한 제어를 외부 메서드로 명령하는 형태로 만든다.
```java
class MemberShip {
    private Grade grade;

    /**
     * 새로 가입한 회원에게는 기본 등급 부여
     */
    public void newCommerGrade() {
        grade = Grade.STANDARD;
    }
}
```
